<resources>
    <string name="app_name">diplomchik</string>
    <string name="app_in_bottom">Войдите в свой аккаунт</string>
    <string name="btnSignIn">Войти</string>
    <string name="btnRegister">Зарегистрироваться</string>
    <string name="email">Email</string>
    <string name="password">Пароль</string>
    <string name="name">Имя</string>
    <string name="number">Номер телефона</string>
    <string name="selection">Выберите тему:</string>
    <string name="button_two">Тема 1
        \nПроцессы тестирования ПО</string>
    <string name="button_three">Тема 2 \nТестирование документации</string>
    <string name="button_four">Тема 3\nВиды тестирования</string>
    <string name="button_five">Тема 4\nЧек-листы</string>
    <string name="button_six">Тема 5\nТест-кейсы</string>
    <string name="button_seven">Тема 6\nОтчёты о дефектах</string>
    <string name="button_eight">Тема 7\nПланирование и отчётность</string>
    <string name="temaOneZagolovok">Процессы тестирования и разработки ПО</string>
    <string name="tema1text1">\tЧтобы лучше разобраться в том, как тестирование соотносится с программированием
        и иными видами проектной деятельности, для начала рассмотрим самые основы — модели разработки ПО.  При этом сразу подчеркнём,
        что разработка ПО является лишь частью жизненного цикла ПО, и здесь мы говорим именно о разработке.
    Материал данной главы относится скорее к дисциплине «управление проектами», потому здесь
        рассмотрен крайне сжато: пожалуйста, не воспринимайте его как исчерпывающее руководство — здесь едва ли рассмотрена
        и сотая доля процента соответствующей предметной области.</string>
    <string name="gold"> \t\tМодель разработки ПО — \n\tструктура,
        систематизирующая \n\tразличные виды проектной \n\tдеятельности, их взаимодействие \n\tи последовательность в процессе \n\tразработки ПО. </string>
    <string name="tema1text1part2"> \tВыбор модели разработки ПО серьёзно
        влияет на процесс тестирования, определяя выбор стратегии, расписание, необходимые ресурсы и т.д. Моделей разработки ПО много,
        но в общем случае классическими можно считать водопадную, v-образную, итерационную инкрементальную, спиральную и гибкую. \n\tЗнать и понимать
        модели разработки ПО необходимо затем, чтобы уже с первых дней работы понимать, что происходит вокруг, что, зачем и почему вы делаете. Многие начинающие тестировщики отмечают,
        что ощущение бессмысленности происходящего посещает их, даже если текущие задания интересны. Чем полнее вы будете представлять картину происходящего на проекте,
        тем яснее вам будет виден ваш собственный вклад в общее дело и смысл того, чем вы занимаетесь.</string>
    <string name="temaOneZagolovok2">Водопадная модель</string>
    <string name="tema1text2">\tВодопадная модель (waterfall model19) сейчас представляет скорее исторический интерес, т. к. в современных проектах практически неприменима.
        Она предполагает однократное выполнение каждой из фаз проекта, которые, в свою очередь, строго следуют друг за другом. Очень упрощённо можно сказать,
        что в рамках этой модели в любой момент времени команде «видна» лишь предыдущая и следующая фаза. В реальной же разработке ПО приходится
        «видеть весь проект целиком» и возвращаться к предыдущим фазам, чтобы исправить недоработки или что-то уточнить.

        </string>
    <string name="temaOneZagolovok3">V-образная модель</string>
    <string name="tema1text3">\tV-образная модель (V-model22) является логическим развитием водопадной. Можно заметить, что в общем случае как водопадная,
        так и v-образная модели жизненного цикла ПО могут содержать один и тот же набор стадий, но принципиальное отличие заключается в том,
        как эта информация используется в процессе реализации проекта. Очень упрощённо можно сказать, что при использовании v-образной модели
        на каждой стадии «на спуске» нужно думать о том, что и как будет происходить на соответствующей стадии «на подъёме». Тестирование здесь
        появляется уже на самых ранних стадиях развития проекта, что позволяет минимизировать риски,
        а также обнаружить и устранить множество потенциальных проблем до того, как они станут проблемами реальными. V-образная модель разработки ПО представлена ниже.
</string>
    <string name="temaOneZagolovok4">Итерационная инкрементальная модель </string>
    <string name="tema1text4">\tИтерационная инкрементальная модель является фундаментальной основой современного подхода к разработке ПО. Как следует из названия модели, ей свойственна определённая двойственность (а ISTQB-глоссарий даже не приводит единого определения, разбивая его на отдельные части):
        \n\t• с точки зрения жизненного цикла модель является итерационной, т.к. подразумевает многократное повторение одних и тех же стадий; \n\t• с точки зрения развития продукта (приращения его полезных функций) модель является инкрементальной. \n\tКлючевой особенностью данной модели является разбиение проекта на относительно небольшие промежутки (итерации), каждый из которых в общем случае может включать в себя все классические стадии, присущие водопадной и v-образной моделям (рисунок 2.1.c). Итогом итерации является приращение (инкремент) функциональности продукта, выраженное в промежуточном билде.
</string>
    <string name="temaOneZagolovok5">Спиральная модель</string>
    <string name="tema1text5">\tСпиральная модель представляет собой частный случай итерационной инкрементальной модели, в котором особое внимание уделяется управлению рисками, в особенности влияющими на организацию процесса разработки проекта и контрольные точки. \tВ спиральной модели ярко выражены четыре ключевые фазы: \n\t• проработка целей, альтернатив и ограничений; \n\t• анализ рисков и прототипирование; \n\t• разработка (промежуточной версии) продукта; \n\t• планирование следующего цикла. \n\tС точки зрения тестирования и управления качеством повышенное внимание рискам является ощутимым преимуществом при использовании спиральной модели для разработки концептуальных проектов, в которых требования естественным образом являются сложными и нестабильными (могут многократно меняться по ходу выполнения проекта).

</string>
    <string name="temaOneZagolovok6">Гибкая модель</string>
    <string name="tema1text6">\tГибкая модель представляет собой совокупность различных подходов к разработке ПО и базируется на т. н. «agile-манифесте»: \n\t• Люди и взаимодействие важнее процессов и инструментов. \n\t• Работающий продукт важнее исчерпывающей документации. \n\t• Сотрудничество с заказчиком важнее согласования условий контракта. \n\t• Готовность к изменениям важнее следования первоначальному плану. \n\tКак несложно догадаться, положенные в основу гибкой модели подходы являются логическим развитием и продолжением всего того, что было за десятилетия создано и опробовано в водопадной, v-образной, итерационной инкрементальной, спиральной и иных моделях. Причём здесь впервые был достигнут ощутимый результат в снижении бюрократической составляющей и максимальной адаптации процесса разработки ПО к мгновенным изменениям рынка и требований заказчика. Главным недостатком гибкой модели считается сложность её применения к крупным проектам, а также частое ошибочное внедрение её подходов, вызванное недопониманием фундаментальных принципов модели.
</string>
    <string name="temaOneZagolovok7">Таблица сравнения моделей разработки ПО</string>
    <string name="temaTwoZagolovok1">Тестирование документации и требований</string>
    <string name="tema2text1">\tКак мы только что рассмотрели в главе, посвящённой жизненному циклу тестирования, всё так или иначе начинается с документации и требований.
</string>

    <string name="tema2text2">\tБрайан Хэнкс, описывая важность требований, подчёркивает, что они:</string>
    <string name="afterblue1">\t Продуктная документация используется проектной командой во время разработки и поддержки продукта. Она включает:
 \n\t• План проекта и в том числе тестовый план.
 \n\t• Требования к программному продукту и функциональные спецификации.
 \n\t• Архитектуру и дизайн.
 \n\t• Тест-кейсы и наборы тест-кейсов.
 \n\t• Технические спецификации, такие как схемы баз данных, описания алгоритмов, интерфейсов и т. д.
 \n\tПроектная документация включает в себя как продуктную документацию, так и некоторые дополнительные виды документации и используется не только на стадии разработки, но и на более ранних и поздних стадиях (например, на стадии внедрения и эксплуатации). Она включает:
    </string>
    <string name="temaTwoZagolovok2">Источники и пути выявления требований</string>
    <string name="tema2text3">\tТребования начинают свою жизнь на стороне заказчика. Их сбор и выявление осуществляются с помощью следующих основных техник.
    \n\tИнтервью. Самый универсальный путь выявления требований, заключающийся в общении проектного специалиста (как правило, специалиста по бизнес-анализу) и представителя заказчика (или эксперта, пользователя и т.д.).
    \n\tРабота с фокусными группами. Может выступать как вариант «расширенного интервью», где источником информации является не одно лицо, а группа лиц (как правило, представляющих собой целевую аудиторию, и/или обладающих важной для проекта информацией, и/или уполномоченных принимать важные для проекта решения).
    \n\tАнкетирование. Этот вариант выявления требований вызывает много споров, т. к. при неверной реализации может привести к нулевому результату при объёмных затратах.
    \n\tСеминары и мозговой штурм. Семинары позволяют группе людей очень быстро обменяться информацией (и наглядно продемонстрировать те или иные идеи).
   </string>
    <string name="temaTwoZagolovok3">Уровни и типы требований</string>
    <string name="tema2text4">\tБизнес-требования выражают цель, ради которой разрабатывается продукт. Результатом выявления требований на этом уровне является общее видение — документ, который, как правило, представлен простым текстом и таблицами.
\n\tПользовательские требования описывают задачи, которые пользователь может выполнять с помощью разрабатываемой системы (реакцию системы на действия пользователя). Поскольку здесь уже появляется описание поведения системы, требования этого уровня могут быть использованы для оценки объёма работ.
\n\tБизнес-правила описывают особенности принятых в предметной области процессов, ограничений и иных правил. Эти правила могут относиться к бизнес-процессам, правилам работы сотрудников, нюансам работы ПО и т.д.
\n\tАтрибуты качества расширяют собой нефункциональные требования и на уровне пользовательских требований могут быть представлены в виде описания ключевых для проекта показателей качества.
\n\tФункциональные требования описывают поведение системы, т. е. её действия (вычисления, преобразования, проверки, обработку и т.д.) В контексте проектирования функциональные требования в основном влияют на дизайн системы.
\n\tНефункциональные требования описывают свойства системы (удобство использования, безопасность, надёжность, расширяемость и т.д.), которыми она должна обладать при реализации своего поведения.
   </string>
    <string name="temaThreeZagolovok1">Упрощённая классификация тестирования</string>
    <string name="tema3text1">\tТестирование можно классифицировать по очень большому количеству признаков, и практически в каждой серьёзной книге о тестировании автор показывает свой (безусловно имеющий право на существование) взгляд на этот вопрос. \n\tСоответствующий материал достаточно объёмен и сложен, а глубокое понимание каждого пункта в классификации требует определённого опыта, потому мы разделим данную тему на две: сейчас мы рассмотрим самый простой, минимальный набор информации, необходимый начинающему тестировщику, а в следующей главе приведём подробную классификацию. \n\tИспользуйте нижеприведённый список как очень краткую «шпаргалку для запоминания». Итак, тестирование можно классифицировать:
</string>
    <string name="tema3text2">
        • По запуску кода на исполнение:
  \n\t•Статическое тестирование — без запуска.
  \n\t•Динамическое тестирование — с запуском.
      </string>
    <string name="razbilpochastyam1">
        •По доступу к коду и архитектуре приложения:
 \n\t•Метод белого ящика — доступ к коду есть.
 \n\t•Метод чёрного ящика — доступа к коду нет.
  \n\t•Метод серого ящика — к части кода доступ есть, к части — нет.
</string>
    <string name="razbilpochastyam2">
        •По степени автоматизации:
  \n\t•Ручное тестирование — тест-кейсы выполняет человек.
  \n\t•Автоматизированное тестирование — тест-кейсы частично или полностью выполняет специальное инструментальное средство.
</string>
    <string name="razbilpochastyam3">
        • По степени важности тестируемых функций:
  \n\t•Дымовое тестирование — проверка самой важной, самой ключевой функциональности, неработоспособность которой делает бессмысленной саму идею использования приложения.
  \n\t•Тестирование критического пути — проверка функциональности, используемой типичными пользователями в типичной повседневной деятельности.
  \n\t•Расширенное тестирование — проверка всей функциональности, заявленной в требованиях.
</string>
    <string name="razbilpochastyam4">
        • По принципам работы с приложением:
  \n\t•Позитивное тестирование — все действия с приложением выполняются строго по инструкции без никаких недопустимых действий, некорректных данных и т. д.
  \n\t•Негативное тестирование — в работе с приложением выполняются операции и используются данные, потенциально приводящие к ошибкам.
</string>
    <string name="razbilpochastyam5">
        \tЧасто возникает вопрос о том, чем различаются «тип тестирования», «вид тестирования», «способ тестирования», «подход к тестированию» и т.д. и т.п. Если вас интересует строгий формальный ответ, посмотрите в направлении таких вещей как «таксономия» и «таксон», т. к. сам вопрос выходит за рамки тестирования как такового и относится уже к области науки.
</string>


    <string name="temaThreeZagolovok2">Классификация по запуску кода на исполнение</string>
    <string name="tema3text3">\tДалеко не всякое тестирование предполагает взаимодействие с работающим приложением. Потому в рамках данной классификации выделяют:
        \n• Статическое тестирование (static testing) — тестирование без запуска кода на исполнение. В рамках этого подхода тестированию могут подвергаться:
 \n\t• Документы (требования, тест-кейсы, описания архитектуры приложения, схемы баз данных и т.д.).
 \n\t• Графические прототипы (например, эскизы пользовательского интерфейса).
 \n\t• Код приложения (что часто выполняется самими программистами в рамках аудита кода, являющегося специфической вариацией взаимного просмотра в применении к исходному коду).
\n\t• Параметры среды исполнения приложения.
 \n\t• Подготовленные тестовые данные.
        \n• Динамическое тестирование — тестирование с запуском кода на исполнение. Запускаться на исполнение может как код всего приложения целиком, так и код нескольких взаимосвязанных частей, отдельных частей и даже отдельные участки кода. Основная идея этого вида тестирования состоит в том, что проверяется реальное поведение приложения.
</string>
    <string name="temaThreeZagolovok3">Классификация по архитектуре приложения</string>
    <string name="temaFourZagolovok1">Чек-листы</string>
    <string name="tema4text1">\tКак легко можно понять из предыдущих глав, тестировщику приходится работать с огромным количеством информации, выбирать из множества вариантов решения задач и изобретать новые.
        В процессе этой деятельности объективно невозможно удержать в голове все мысли, а потому продумывание и разработку тест-кейсов рекомендуется выполнять с использованием так называемых «чек-листов».
     </string>
    <string name="tema4text11">
        \tЧек-лист — набор идей . Последнее слово не зря взято в скобки, т. к. в общем случае чек-лист — это просто набор идей: идей по тестированию, идей по разработке, идей по планированию и управлению — любых идей.
    </string>
    <string name="tema4text12">
        \tЧек-лист чаще всего представляет собой обычный и привычный нам список, который может быть:
      </string>
    <string name="tema4text13">
        • Списком, в котором последовательность пунктов не имеет значения (например, список значений некоего поля).
       \n • Списком, в котором последовательность пунктов важна (например, шаги в краткой инструкции).
       \n • Структурированным списком, что позволяет отразить иерархию идей.
      </string>
    <string name="tema4text14">
        \tДля того чтобы чек-лист был действительно полезным инструментом, он должен обладать рядом важных свойств.
        \n\tЛогичность. Чек-лист пишется не «просто так», а на основе целей и для того, чтобы помочь в достижении этих целей.
\n\tПоследовательность и структурированность. Со структурированностью всё достаточно просто — она достигается за счёт оформления чек-листа в виде многоуровневого списка. Что до последовательности, то даже в том случае, когда пункты чек-листа не описывают цепочку действий, человеку всё равно удобнее воспринимать информацию в виде неких небольших групп идей, переход между которыми является понятным и очевидным.
\n\tПолнота и неизбыточность. Чек-лист должен представлять собой аккуратную «сухую выжимку» идей, в которых нет дублирования, и в то же время ничто важное не упущено.
    </string>
    <string name="temaFourZagolovok2">Функции, без которых приложение теряет смысл</string>
    <string name="tema4text2">
        \tКонфигурирование и запуск. Если приложение невозможно настроить для работы в пользовательской среде, оно бесполезно. Если приложение не запускается, оно бесполезно. Если на стадии запуска возникают проблемы, они могут негативно отразиться на функционировании приложения и потому также заслуживают пристального внимания.
\n\tОбработка файлов. Ради этого приложение и разрабатывалось, потому здесь даже на стадии создания чек-листа мы не поленились создать матрицу, отражающую все возможные комбинации допустимых форматов и допустимых кодировок входных файлов, чтобы ничего не забыть и подчеркнуть важность соответствующих проверок.
\n\tОстановка. С точки зрения пользователя эта функция может не казаться столь уж важной, но остановка (и запуск) любого приложения связаны с большим количеством системных операций, проблемы с которыми могут привести к множеству серьёзных последствий (вплоть до невозможности повторного запуска приложения или нарушения работы операционной системы).
    </string>
    <string name="temaFourZagolovok3">Функции, востребованные большинством пользователей</string>
    <string name="tema4text3">
       \tСледующим шагом мы будем выполнять проверку того, как приложение ведёт себя в обычной повседневной жизни, пока не затрагивая экзотические ситуации. Очень частым вопросом является допустимость дублирования проверок на разных уровнях функционального тестирования — можно ли так делать. Одновременно и «нет», и «да». «Нет» в том смысле, что не допускается (не имеет смысла) повторение тех же проверок, которые только что были выполнены. «Да» в том смысле, что любую проверку можно детализировать и снабдить дополнительными деталями.
</string>
    <string name="tema4text16">
        •Конфигурирование и запуск:
 \n\t•С верными параметрами:
 \n\t •Значения SOURCE_DIR, DESTINATION_DIR, LOG_FILE_NAME указаны и содержат пробелы и кириллические символы (повторить для форматов путей в Windows и *nix файловых системах, обратить внимание на имена логических дисков и разделители имён каталогов (“/” и “\”)).
 \n\t •Значение LOG_FILE_NAME не указано.
 \n\t•Без параметров.
 \n\t•С недостаточным количеством параметров.
 \n\t•С неверными параметрами:
 \n\t• Недопустимый путь SOURCE_DIR.
 \n\t• Недопустимый путь DESTINATION_DIR.
 \n\t• Недопустимое имя LOG_FILE_NAME.
 \n\t• DESTINATION_DIR находится внутри SOURCE_DIR.
 \n\t• Значения DESTINATION_DIR и SOURCE_DIR совпадают.

    </string>
    <string name="temaFiveZagolovok1">Тест-кейс и его жизненный цикл</string>
    <string name="tema5text1">\tТест — набор из одного или нескольких тест-кейсов.
        \n\tПоскольку среди всех прочих терминов этот легче и быстрее всего произносить, в зависимости от контекста под ним могут понимать и отдельный пункт чек-листа, и отдельный шаг в тест-кейсе, и сам тест-кейс, и набор тест-кейсов и… продолжать можно долго. Главное здесь одно: если вы слышите или видите слово «тест», воспринимайте его в контексте.
        \n\tТеперь рассмотрим самый главный для нас термин — «тест-кейс».
        \n\tТест-кейс — набор входных данных, условий выполнения и ожидаемых результатов, разработанный с целью проверки того или иного свойства или поведения программного средства.
        \n\tПод тест-кейсом также может пониматься соответствующий документ, представляющий формальную запись тест-кейса.
        \n\tВысокоуровневый тест-кейс — тест-кейс без конкретных входных данных и ожидаемых результатов.
        \n\tКак правило, ограничивается общими идеями и операциями, схож по своей сути с подробно описанным пунктом чек-листа. Достаточно часто встречается в интеграционном тестировании и системном тестировании, а также на уровне дымового тестирования. Может служить отправной точкой для проведения исследовательского тестирования или для создания низкоуровневых тест-кейсов.
        \n\tНизкоуровневый тест-кейс — тест-кейс с конкретными входными данными и ожидаемыми результатами.
        \n\tПредставляет собой «полностью готовый к выполнению» тест-кейс и вообще является наиболее классическим видом тест-кейсов. Начинающих тестировщиков чаще всего учат писать именно такие тесты, т.к. прописать все данные подробно — намного проще, чем понять, какой информацией можно пренебречь, при этом не снизив ценность тест-кейса.
        \n\tСпецификация тест-кейса — документ, описывающий набор тест-кейсов (включая их цели, входные данные, условия и шаги выполнения, ожидаемые результаты) для тестируемого элемента.
        \n\tСпецификация теста — документ, состоящий из спецификации тест-дизайна, спецификации тест-кейса и/или спецификации тест-процедуры.
        \n\tТест-сценарий — документ, описы вающий последовательность действий по выполнению теста (также известен как «тест-скрипт»).

</string>
    <string name="temaFiveZagolovok2">Цель написания тест-кейсов</string>
    <string name="tema5text2">\tТестирование можно проводить и без тест-кейсов (не нужно, но можно; да, эффективность такого подхода варьируется в очень широком диапазоне в зависимости от множества факторов). Наличие же тест-кейсов позволяет:
    \n\t• Структурировать и систематизировать подход к тестированию (без чего крупный проект почти гарантированно обречён на провал).
        \n\t• Вычислять метрики тестового покрытия и принимать меры по его увеличению (тест-кейсы здесь являются главным источником информации, без которого существование подобных метрик теряет смысл).
        \n\t• Отслеживать соответствие текущей ситуации плану (сколько примерно понадобится тест-кейсов, сколько уже есть, сколько выполнено из запланированного на данном этапе количества и т.д.).
        \n\t• Уточнить взаимопонимание между заказчиком, разработчиками и тестировщиками (тест-кейсы зачастую намного более наглядно показывают поведение приложения, чем это отражено в требованиях).
        \n\t• Хранить информацию для длительного использования и обмена опытом между сотрудниками и командами (или как минимум — не пытаться удержать в голове сотни страниц текста).
        \n\t• Проводить регрессионное тестирование и повторное тестирование (которые без тест-кейсов было бы вообще невозможно выполнить).
        \n\t• Повышать качество требований (мы это уже рассматривали: написание чек-листов и тест-кейсов — хорошая техника тестирования требований).
        \n\t• Быстро вводить в курс дела нового сотрудника, недавно подключившегося к проекту.
    </string>
    <string name="temaFiveZagolovok3">Жизненный цикл тест-кейса</string>
    <string name="tema5text3">\tВ отличие от отчёта о дефекте, у которого есть полноценный развитый жизненный цикл, для тест-кейса речь скорее идёт о наборе состояний, в которых он может находиться (жирным шрифтом отмечены наиболее важные состояния). Жизненный цикл тест-кейса изображён на рисунке ниже.</string>
    <string name="temaFiveZagolovok4">Атрибуты тест-кейса</string>
    <string name="tema5text4">
        \tКак уже было сказано выше, термин «тест-кейс» может относиться к формальной записи тест-кейса в виде технического документа. Эта запись имеет общепринятую структуру, компоненты которой называются атрибутами (полями) тест-кейса.
        \n\tВ зависимости от инструмента управления тест-кейсами внешний вид их записи может немного отличаться, могут быть добавлены или убраны отдельные поля, но концепция остаётся неизменной.
        \n\tОбщий вид всей структуры тест-кейса представлен на рисунке.


    </string>
    <string name="tema5text5">
        \tТеперь рассмотрим каждый атрибут подробно.
        \n\tИдентификатор представляет собой уникальное значение, позволяющее однозначно отличить один тест-кейс от другого и используемое во всевозможных ссылках. В общем случае идентификатор тест-кейса может представлять собой просто уникальный номер, но (если позволяет инструментальное средство управления тест-кейсами) может быть и куда сложнее: включать префиксы, суффиксы и иные осмысленные компоненты, позволяющие быстро определить цель тест-кейса и часть приложения (или требований), к которой он относится.
\n\tПриоритет показывает важность тест-кейса. Он может быть выражен буквами (A, B, C, D, E), цифрами (1, 2, 3, 4, 5), словами («крайне высокий», «высокий», «средний», «низкий», «крайне низкий») или иным удобным способом. Количество градаций также не фиксировано, но чаще всего лежит в диапазоне от трёх до пяти.
\n\tСвязанное с тест-кейсом требование показывает то основное требование, проверке выполнения которого посвящён тест-кейс (основное — потому, что один тест-кейс может затрагивать несколько требований). Наличие этого поля улучшает такое свойство тест-кейса, как прослеживаемость.
\n\tМодуль и подмодуль приложения указывают на части приложения, к которым относится тест-кейс, и позволяют лучше понять его цель.
        \n\tИдея деления приложения на модули и подмодули проистекает из того, что в сложных системах практически невозможно охватить взглядом весь проект целиком, и вопрос «как протестировать это приложение» становится недопустимо сложным. Тогда приложение логически разделяется на компоненты (модули), а те, в свою очередь, на более мелкие компоненты (подмодули). И вот уже для таких небольших частей приложения придумать чек-листы и создать хорошие тест-кейсы становится намного проще.
        \n\tКак правило, иерархия модулей и подмодулей создаётся как единый набор для всей проектной команды, чтобы исключить путаницу из-за того, что разные люди будут использовать разные подходы к такому разделению или даже просто разные названия одних и тех же частей приложения.
\n\tЗаглавие (суть) тест-кейса (title) призвано упростить и ускорить понимание основной идеи (цели) тест-кейса без обращения к его остальным атрибутам. Именно это поле является наиболее информативным при просмотре списка тест-кейсов.
        \n\tЗаглавие тест-кейса может быть полноценным предложением, фразой, набором словосочетаний — главное, чтобы выполнялись следующие условия:
        \n\t• Информативность.
        \n\t• Хотя бы относительная уникальность (чтобы не путать разные тест-кейсы).
        \n\tШаги тест-кейса (steps) описывают последовательность действий, которые необходимо реализовать в процессе выполнения тест-кейса. Общие рекомендации по написанию шагов таковы:
        \n\t• начинайте с понятного и очевидного места, не пишите лишних начальных шагов (запуск приложения, очевидные операции с интерфейсом и т. п.);
        \n\t• даже если в тест-кейсе всего один шаг, нумеруйте его (иначе возрастает вероятность в будущем случайно «приклеить» описание этого шага к новому тексту);
        \n\t• если вы пишете на русском языке, используйте безличную форму (например, «открыть», «ввести», «добавить» вместо «откройте», «введите», «добавьте»), в английском языке не надо использовать частицу «to» (т. е. «запустить приложение» будет «start application», не «to start application»);
        \n\t• соотносите степень детализации шагов и их параметров с целью тест-кейса, его сложностью, уровнем{80} и т. д. — в зависимости от этих и многих других факторов степень детализации может варьироваться от общих идей до предельно чётко прописанных значений и указаний;
        \n\t• ссылайтесь на предыдущие шаги и их диапазоны для сокращения объёма текста (например, «повторить шаги 3–5 со значением…»);
        \n\t• пишите шаги последовательно, без условных конструкций вида «если… то…».
        \n\tОжидаемые результаты (expected results) по каждому шагу тест-кейса описывают реакцию приложения на действия, описанные в поле «шаги тест-кейса». Номер шага соответствует номеру результата.
        \n\tПо написанию ожидаемых результатов можно порекомендовать следующее:
        \n\t• описывайте поведение системы так, чтобы исключить субъективное толкование (например, «приложение работает верно» — плохо, «появляется окно с надписью…» — хорошо);
        \n\t• пишите ожидаемый результат по всем шагам без исключения, если у вас есть хоть малейшие сомнения в том, что результат некоего шага будет совершенно тривиальным и очевидным (если вы всё же пропускаете ожидаемый результат для какого-то тривиального действия, лучше оставить в списке ожидаемых результатов пустую строку — это облегчает восприятие);
        \n\t• пишите кратко, но не в ущерб информативности; • избегайте условных конструкций вида «если… то…».
    </string>
    <string name="temaFiveZagolovok5">Свойства качественных тест-кейсов</string>
    <string name="tema5text6">
        \tПравильный технический язык, точность и единообразие формулировок. Это свойство в равной мере относится и к требованиям, и к тест-кейсам, и к отчётам о дефектах — к любой документации. Основные идеи уже были описаны, а из самого общего и важного напомним и добавим:
        \n\t• пишите лаконично, но понятно;
        \n\t• используйте безличную форму глаголов (например, «открыть» вместо «откройте»);
        \n\t• обязательно указывайте точные имена и технически верные названия элементов приложения;
        \n\t• не объясняйте базовые принципы работы с компьютером (предполагается, что ваши коллеги знают, что такое, например, «пункт меню» и как с ним работать);
        \n\t• везде называйте одни и те же вещи одинаково (например, нельзя в одном тест-кейсе некий режим работы приложения назвать «графическое представление», а в другом тот же режим — «визуальное отображение», т. к. многие люди могут подумать, что речь идёт о разных вещах);
        \n\t• следуйте принятому на проекте стандарту оформления и написания тест-кейсов (иногда такие стандарты могут быть весьма жёсткими: вплоть до регламентации того, названия каких элементов должны быть приведены в двойных кавычках, а каких — в одинарных).
        \n\tБаланс между специфичностью и общностью. Тест-кейс считается тем более специфичным, чем более детально в нём расписаны конкретные действия, конкретные значения и т. д., т. е. чем в нём больше конкретики. Соответственно, тест-кейс считается тем более общим, чем в нём меньше конкретики.
        \n\tБаланс между простотой и сложностью. Здесь не существует академических определений, но принято считать, что простой тест-кейс оперирует одним объектом (или в нём явно виден главный объект), а также содержит небольшое количество тривиальных действий; сложный тест-кейс оперирует несколькими равноправными объектами и содержит много нетривиальных действий.
        \n\tПреимущества простых тест-кейсов:
        \n\t• их можно быстро прочесть, легко понять и выполнить;
        \n\t• они понятны начинающим тестировщикам и новым людям на проекте;
        \n\t• они делают наличие ошибки очевидным (как правило, в них предполагается выполнение повседневных тривиальных действий, проблемы с которыми видны невооружённым взглядом и не вызывают дискуссий);
        \n\t• они упрощают начальную диагностику ошибки, т.к. сужают круг поиска. Преимущества сложных тест-кейсов:
        \n\t• при взаимодействии многих объектов повышается вероятность возникновения ошибки;
        \n\t• пользователи, как правило, используют сложные сценарии, а потому сложные тесты более полноценно эмулируют работу пользователей;
        \n\t• программисты редко проверяют такие сложные случаи (и они совершенно не обязаны это делать).
        \n\t«Показательность» (высокая вероятность обнаружения ошибки). Начиная с уровня тестирования критического пути, можно утверждать, что тест-кейс является тем более хорошим, чем он более показателен (с большей вероятностью обнаруживает ошибку). Именно поэтому мы считаем непригодными слишком простые тест-кейсы — они непоказательны.
        \n\tПоследовательность в достижении цели. Суть этого свойства выражается в том, что все действия в тест-кейсе направлены на следование единой логике и достижение единой цели и не содержат никаких отклонений.
        \n\tДемонстративность (способность демонстрировать обнаруженную ошибку очевидным образом). Ожидаемые результаты должны быть подобраны и сформулированы таким образом, чтобы любое отклонение от них сразу же бросалось в глаза и становилось очевидным, что произошла ошибка. Сравните выдержки из двух тест-кейсов.
        \n\tПрослеживаемость. Из содержащейся в качественном тест-кейсе информации должно быть понятно, какую часть приложения, какие функции и какие требования он проверяет. Частично это свойство достигается через заполнение соответствующих полей тест-кейса («Ссылка на требование», «Модуль», «Подмодуль»), но и сама логика тест-кейса играет не последнюю роль, т. к. в случае серьёзных нарушений этого свойства можно долго с удивлением смотреть, например, на какое требование ссылается тест-кейс, и пытаться понять, как же они друг с другом связаны.
        \n\tПовторяемость. Тест-кейс должен быть сформулирован таким образом, чтобы при многократном повторении он показывал одинаковые результаты. Это свойство можно разделить на два подпункта:
        \n\t• во-первых, даже общие формулировки, допускающие разные варианты выполнения тест-кейса, должны очерчивать соответствующие явные границы (например: «ввести какое-нибудь число» — плохо, «ввести целое число в диапазоне от -273 до +500 включительно» — хорошо);
        \n\t• действия (шаги) тест-кейса по возможности не должны приводить к необратимым (или сложно обратимым) последствиям (например: удалению данных, нарушению конфигурации окружения и т. д.) — не стоит включать в тест-кейс такие «разрушительные действия», если они не продиктованы явным образом целью тест-кейса; если же цель тест-кейса обязывает нас к выполнению таких действий, в самом тест-кейсе должно быть описание действий по восстановлению исходного состояния приложения (данных, окружения).
        \n\tСоответствие принятым шаблонам оформления и традициям. С шаблонами оформления, как правило, проблем не возникает: они строго определены имеющимся образцом или вообще экранной формой инструментального средства управления тест-кейсами. Что же касается традиций, то они отличаются даже в разных командах в рамках одной компании, и тут невозможно дать иного совета, кроме как «почитайте уже готовые тест-кейсы перед тем как писать свои».
        \n\tВ данном случае обойдёмся без отдельных примеров, т.к. выше и без того приведено много правильно оформленных тест-кейсов, а что касается нарушений этого свойства, то они прямо или косвенно описаны в главе «Типичные ошибки при разработке чек-листов, тест-кейсов и наборов тест-кейсов».

    </string>
    <string name="temaFiveZagolovok6">Наборы тест-кейсов</string>
    <string name="tema5text7">
        \tНабор тест-кейсов — совокупность тест-кейсов, выбранных с некоторой общей целью или по некоторому общему признаку. Иногда в такой совокупности результаты завершения одного тест-кейса становятся входным состоянием приложения для следующего тест-кейса.
        \n\tКак мы только что убедились на примере множества отдельных тест-кейсов, крайне неудобно (более того, это ошибка!) каждый раз писать в каждом тест-кейсе одни и те же приготовления и повторять одни и те же начальные шаги.
        \n\tНамного удобнее объединить несколько тест-кейсов в набор или последовательность. И здесь мы приходим к классификации наборов тест-кейсов.
        \n\tВ общем случае наборы тест-кейсов можно разделить на свободные (порядок выполнения тест-кейсов не важен) и последовательные (порядок выполнения тест-кейсов важен).
        \n\tПреимущества свободных наборов:
        \n\t• Тест-кейсы можно выполнять в любом удобном порядке, а также создавать «наборы внутри наборов».
        \n\t• Если какой-то тест-кейс завершился ошибкой, это не повлияет на возможность выполнения других тест-кейсов.
        \n\tПреимущества последовательных наборов:
        \n\t• Каждый следующий в наборе тест-кейс в качестве входного состояния приложения получает результат работы предыдущего тест-кейса, что позволяет сильно сократить количество шагов в отдельных тест-кейсах.
        \n\t• Длинные последовательности действий куда лучше имитируют работу реальных пользователей, чем отдельные «точечные» воздействия на приложение.
    </string>
    <string name="temaSixZagolovok1">Отчёт о дефекте и его жизненный цикл</string>
    <string name="tema6text1">
\tКак было сказано в предыдущей главе, при обнаружении дефекта тестировщик создаёт отчёт о дефекте.
        \n\tОтчёт о дефекте — документ, описывающий и приоритизирующий обнаруженный дефект, а также содействующий его устранению.
\n\tКак следует из самого определения, отчёт о дефекте пишется со следующими основными целями:
        \n\t• предоставить информацию о проблеме — уведомить проектную команду и иных заинтересованных лиц о наличии проблемы, описать суть проблемы;
        \n\t• приоритизировать проблему — определить степень опасности проблемы для проекта и желаемые сроки её устранения;
        \n\t• содействовать устранению проблемы — качественный отчёт о дефекте не только предоставляет все необходимые подробности для понимания сути случившегося, но также может содержать анализ причин возникновения проблемы и рекомендации по исправлению ситуации.
        \n\tОтчёт о дефекте (и сам дефект вместе с ним) проходит определённые стадии жизненного цикла, которые схематично можно показать так, как на рисунке.
    </string>
    <string name="temaSixZagolovok2">Атрибуты отчёта о дефекте</string>
    <string name="tema6text2">В зависимости от инструментального средства управления отчётами о дефектах внешний вид их записи может немного отличаться, могут быть добавлены или убраны отдельные поля, но концепция остаётся неизменной. Общий вид всей структуры отчёта о дефекте представлен на рисунке. </string>
    <string name="tema6text3">
        \tИдентификатор представляет собой уникальное значение, позволяющее однозначно отличить один отчёт о дефекте от другого и используемое во всевозможных ссылках. В общем случае идентификатор отчёта о дефекте может представлять собой просто уникальный номер, но (если позволяет инструментальное средство управления отчётами) может быть и куда сложнее: включать префиксы, суффиксы и иные осмысленные компоненты, позволяющие быстро определить суть дефекта и часть приложения (или требований), к которой он относится.
\n\tКраткое описание (summary) должно в предельно лаконичной форме давать исчерпывающий ответ на вопросы «Что произошло?» «Где это произошло»? «При каких условиях это произошло?». Например: «Отсутствует логотип на странице приветствия, если пользователь является администратором»:
        \n\t• Что произошло? Отсутствует логотип.
        \n\t• Где это произошло? На странице приветствия.
        \n\t• При каких условиях это произошло? Если пользователь является администратором.
        \n\tОдной из самых больших проблем для начинающих тестировщиков является именно заполнение поля «краткое описание», которое одновременно должно:
        \n\t• содержать предельно краткую, но в то же время достаточную для понимания сути проблемы информацию о дефекте;
        \n\t• отвечать на только что упомянутые вопросы («что, где и при каких условиях случилось») или как минимум на те 1–2 вопроса, которые применимы к конкретной ситуации;
        \n\t• быть достаточно коротким, чтобы полностью помещаться на экране (в тех системах управления отчётами о дефектах, где конец этого поля обрезается или приводит к появлению скроллинга);
        \n\t• при необходимости содержать информацию об окружении, под которым был обнаружен дефект;
        \n\t• по возможности не дублировать краткие описания других дефектов (и даже не быть похожими на них), чтобы дефекты было сложно перепутать или посчитать дубликатами друг друга;
        \n\t• быть законченным предложением русского или английского (или иного) языка, построенным по соответствующим правилам грамматики.
        \n\t  Примеры из разработки программного обеспечения и четыре случая сочетания важности и срочности.
        \n\tСимптом (symptom) — позволяет классифицировать дефекты по их типичному проявлению. Не существует никакого общепринятого списка симптомов. Более того, далеко не в каждом инструментальном средстве управления отчётами о дефектах есть такое поле, а там, где оно есть, его можно настроить. В качестве примера рассмотрим следующие значения симптомов дефекта.
        \n\tВозможность обойти (workaround) — показывает, существует ли альтернативная последовательность действий, выполнение которой позволило бы пользователю достичь поставленной цели (например, клавиатурная комбинация Ctrl+P не работает, но распечатать документ можно, выбрав соответствующие пункты в меню). В некоторых инструментальных средствах управления отчётами о дефектах это поле может просто принимать значения «Да» и «Нет», в некоторых при выборе «Да» появляется возможность описать обходной путь. Традиционно считается, что дефектам без возможности обхода стоит повысить срочность исправления.
        \n\tКомментарий (comments, additional info) — может содержать любые полезные для понимания и исправления дефекта данные. Иными словами, сюда можно писать всё то, что нельзя писать в остальные поля.
        \n\tПриложения (attachments) — представляет собой не столько поле, сколько список при креплённых к отчёту о дефекте приложений (копий экрана, вызывающих сбой файлов и т. д.).

    </string>
    <string name="temaSevenZagolovok1">Планирование и отчётность</string>
    <string name="tema7text1">
        \tДаже если допустить, что мы идеально знаем все технические аспекты предстоящей работы, неотвеченными остаются такие вопросы, как:
        \n\t• Когда и с чего начать?
        \n\t• Всё ли необходимое для выполнения работы у нас есть? Если нет, где взять недостающее?
        \n\t• В какой последовательности выполнять разные виды работ?
        \n\t• Как распределить ответственность между участниками команды?
        \n\t• Как организовать отчётность перед заинтересованными лицами?
        \n\t• Как объективно определять прогресс и достигнутые успехи?
        \n\t• Как заранее увидеть возможные проблемы, чтобы успеть их предотвратить?
        \n\t• Как организовать нашу работу так, чтобы при минимуме затрат получить максимум результата?
        \n\tЭти и многие подобные им вопросы уже лежат вне технической области — они относятся к управлению проектом. Эта задача сама по себе огромна, потому мы рассмотрим лишь малую её часть, с которой многим тестировщикам приходится иметь дело, — планирование и отчётность.
        \n\tКаждая итерация начинается с планирования и заканчивается отчётностью, которая становится основой для планирования следующей итерации — и так далее. Таким образом, планирование и отчётность находятся в тесной взаимосвязи, и проблемы с одним из этих видов деятельности неизбежно приводят к проблемам с другим видом, а в конечном итоге и к проблемам с проектом в целом. Взаимосвязь планирования и отчётности представлена на рисунке.

    </string>
    <string name="tema7text2">
        \tПланирование — непрерывный процесс принятия управленческих решений и методической организации усилий по их реализации с целью обеспечения качества некоторого процесса на протяжении длительного периода времени.
\n\tК высокоуровневым задачам планирования относятся:
        \n\t• снижение неопределённости;
        \n\t• повышение эффективности;
        \n\t• улучшение понимания целей;
        \n\t• создание основы для управления процессами.
        \n\tОтчётность (reporting328) — сбор и распространение информации о результатах работы (включая текущий статус, оценку прогресса и прогноз развития ситуации).
\n\tК высокоуровневым задачам отчётности относятся:
        \n\t• сбор, агрегация и предоставление в удобной для восприятия форме объективной информации о результатах работы;
        \n\t• формирование оценки текущего статуса и прогресса (в сравнении с планом);
        \n\t• обозначение существующих и возможных проблем (если такие есть);
        \n\t• формирование прогноза развития ситуации и фиксация рекомендаций по устранению проблем и повышению эффективности работы.

    </string>
    <string name="temaSevenZagolovok2">
        Тест-план и отчёт о результатах тестирования
    </string>
    <string name="tema7text3">
        \tТест-план — документ, описывающий и регламентирующий перечень работ по тестированию, а также соответствующие техники и подходы, стратегию, области ответственности, ресурсы, расписание и ключевые даты.
        \n\tК низкоуровневым задачам планирования в тестировании относятся:
        \n\t• оценка объёма и сложности работ;
        \n\t• определение необходимых ресурсов и источников их получения;
        \n\t• определение расписания, сроков и ключевых точек;
        \n\t• оценка рисков и подготовка превентивных контрмер;
        \n\t• распределение обязанностей и ответственности;
        \n\t• согласование работ по тестированию с деятельностью участников проектной команды, занимающихся другими задачами.
        \n\tКак и любой другой документ, тест-план может быть качественным или обладать недостатками. Качественный тест-план обладает большинством свойств качественных требований, а также расширяет их набор следующими пунктами:
        \n\t• Реалистичность (запланированный подход реально выполним).
        \n\t• Гибкость (качественный тест-план не только является модифицируемым с точки зрения работы с документом, но и построен таким образом, чтобы при возникновении непредвиденных обстоятельств допускать быстрое изменение любой из своих частей без нарушения взаимосвязи с другими частями).
        \n\t• Согласованность с общим проектным планом и иными отдельными планами (например, планом разработки).
\n\tВ общем случае тест-план включает следующие разделы (примеры их наполнения будут показаны далее, потому здесь — только перечисление).
        \n• Цель (purpose). Предельно краткое описание цели разработки приложения (частично это напоминает бизнес-требования, но здесь информация подаётся в ещё более сжатом виде и в контексте того, на что следует обращать первостепенное внимание при организации тестирования и повышения качества).
        \n• Области, подвергаемые тестированию (features to be tested). Перечень функций и/или нефункциональных особенностей приложения, которые будут подвергнуты тестированию. В некоторых случаях здесь также приводится приоритет соответствующей области.
        \n• Области, не подвергаемые тестированию (features not to be tested). Перечень функций и/или нефункциональных особенностей приложения, которые не будут подвергнуты тестированию. Причины исключения той или иной области из списка тестируемых могут быть самыми различными — от предельно низкой их важности для заказчика до нехватки времени или иных ресурсов. Этот перечень составляется, чтобы у проектной команды и иных заинтересованных лиц было чёткое единое понимание, что тестирование таких-то особенностей приложения не запланировано — такой подход позволяет исключить появление ложных ожиданий и неприятных сюрпризов.
        \n• Тестовая стратегия (test strategy) и подходы (test approach). Описание процесса тестирования с точки зрения применяемых методов, подходов, видов тестирования, технологий, инструментальных средств и т. д.
        \n• Критерии (criteria). Этот раздел включает следующие подразделы:
        \n\t• Приёмочные критерии, критерии качества (acceptance criteria) — любые объективные показатели качества, которым разрабатываемый продукт должен соответствовать с точки зрения заказчика или пользователя, чтобы считаться готовым к эксплуатации.
        \n\t• Критерии начала тестирования (entry criteria) — перечень условий, при выполнении которых команда приступает к тестированию. Наличие этого критерия страхует команду от бессмысленной траты усилий в условиях, когда тестирование не принесёт ожидаемой пользы.
        \n\t• Критерии приостановки тестирования (suspension criteria) — перечень условий, при выполнении которых тестирование приостанавливается. Наличие этого критерия также страхует команду от бессмысленной траты усилий в условиях, когда тестирование не принесёт ожидаемой пользы.
        \n\t• Критерии возобновления тестирования (resumption criteria) — перечень условий, при выполнении которых тестирование возобновляется (как правило, после приостановки).
        \n\t• Критерии завершения тестирования (exit criteria) — перечень условий, при выполнении которых тестирование завершается. Наличие этого критерия страхует команду как от преждевременного прекращения тестирования, так и от продолжения тестирования в условиях, когда оно уже перестаёт приносить ощутимый эффект.
        \n• Ресурсы (resources). В данном разделе тест-плана перечисляются все необходимые для успешной реализации стратегии тестирования ресурсы, которые в общем случае можно разделить на:
        \n\t• программные ресурсы (какое ПО необходимо команде тестировщиков, сколько копий и с какими лицензиями (если речь идёт о коммерческом ПО));
 \n\t• аппаратные ресурсы (какое аппаратное обеспечение, в каком количестве и к какому моменту необходимо команде тестировщиков);
 \n\t• человеческие ресурсы (сколько специалистов какого уровня и со знаниями в каких областях должно подключиться к команде тестировщиков в тот или иной момент времени);
 \n\t• временные ресурсы (сколько по времени займёт выполнение тех или иных работ);
 \n\t• финансовые ресурсы (в какую сумму обойдётся использование имеющихся или получение недостающих ресурсов, перечисленных в предыдущих пунктах этого списка); во многих компаниях финансовые ресурсы могут быть представлены отдельным документом, т. к. являются конфиденциальной информацией.
        \n• Расписание (test schedule). Фактически это календарь, в котором указано, что и к какому моменту должно быть сделано. Особое внимание уделяется т.н. «ключевым точкам» (milestones), к моменту наступления которых должен быть получен некий значимый ощутимый результат.
        \n• Роли и ответственность (roles and responsibility). Перечень необходимых ролей (например, «ведущий тестировщик», «эксперт по оптимизации производительности») и область ответственности специалистов, выполняющих эти роли.
        \n• Оценка рисков (risk evaluation). Перечень рисков, которые с высокой вероятностью могут возникнуть в процессе работы над проектом. По каждому риску даётся оценка представл яемой им угрозы и приводятся варианты выхода из ситуации.
        \n• Документация (documentation). Перечень используемой тестовой документации с указанием, кто и когда должен её готовить и кому передавать.
        \n• Метрики (metrics). Числовые характеристики показателей качества, способы их оценки, формулы и т. д. На этот раздел, как правило, формируется множество ссылок из других разделов тест-план

    </string>
    <string name="temaSevenZagolovok3">Оценка трудозатрат</string>
    <string name="tema7text4">
        \tТрудозатраты — количество рабочего времени, необходимого для выполнения работы (выражается в человеко-часах).
\n\tКаждый раз, когда вы получаете задание или выдаёте кому-то задание, явно или неявно возникают вопросы наподобие следующих:
        \n\t• Как много времени понадобится на выполнение работы?
        \n\t• Когда всё будет готово?
        \n\t• Можно ли гарантированно выполнить работу к такому-то сроку?
        \n\t• Каковы наиболее оптимистичный и пессимистичный прогнозы по времени?
        \n\tРассмотрим несколько соображений относительно того, как производится оценка трудозатрат.
        \n\tЛюбая оценка лучше её отсутствия. Даже если область предстоящей работы для вас совершенно нова, даже если вы ошибётесь в своей оценке на порядок, вы как минимум получите опыт, который сможете использовать в будущем при возникновении подобного рода задач.
        \n\tОптимизм губителен. Как правило, люди склонны недооценивать сложность незнакомых задач, что приводит к занижению оценки трудозатрат. Но даже при достаточно точном определении самих трудозатрат люди без опыта выполнения оценки склонны рассматривать предстоящую работу как некую изолированную деятельность, забывая о том, что на протяжении любого рабочего дня «чистую производительность труда» будут снижать такие факторы, как переписка по почте, участие в собраниях и обсуждениях, решение сопутствующих технических вопросов, изучение документации и обдумывание сложных частей задачи, форс-мажорные обстоятельства (неотложные дела, проблемы с техникой и т. д.). Таким образом, обязательно стоит учитывать, что в реальности вы сможете заниматься поставленной задачей не 100 % рабочего времени, а меньше (насколько меньше — зависит от конкретной ситуации, в среднем принято считать, что на поставленную задачу из каждых восьми рабочих часов вы сможете потратить не более шести). Учитывая этот факт, стоит сделать соответствующие поправки в оценке общего времени, которое понадобится на выполнение работы (а именно оно чаще всего интересует постановщика задачи).
        \n\tОценка должна быть аргументирована. Это не значит, что вы всегда должны пускаться в подробные пояснения, но вы должны быть готовы объяснить, почему вы считаете, что та или иная работа займёт именно столько времени. Во-первых, продумывая эти аргументы, вы получаете дополнительную возможность лучше оценить предстоящую работу и скорректировать оценку. Во-вторых, если ваша оценка не соответствует ожиданиям постановщика задачи, вы сможете отстоять свою точку зрения.
        \n\tПростой способ научиться оценивать — оценивать. В специализированной литературе приводится множество технологий, но первична сама привычка выполнять оценку предстоящей работы. В процессе выработки этой привычки вы естественным образом встретитесь с большинством типичных проблем и через некоторое время научитесь делать соответствующие поправки в оценке, даже не задумываясь.

    </string>
    <string name="temaSevenZagolovok4">
        Алгоритм обучения формированию оценки
    </string>
    <string name="tema7text5">
        \t• Сформируйте оценку. Ранее уже было отмечено, что нет ничего страшного в том, что полученное значение может оказаться очень далёким от реальности. Для начала оно просто должно быть.
        \n\t• Запишите полученную оценку. Обязательно именно запишите. Это застрахует вас как минимум от двух рисков: забыть полученное значение (особенно, если работа заняла много времени), соврать себе в стиле «ну, я как-то примерно так и думал».
        \n\t• Выполните работу. В отдельных случаях люди склонны подстраиваться под заранее сформированную оценку, ускоряя или замедляя выполнение работы, — это тоже полезный навык, но сейчас такое поведение будет мешать. Однако если вы будете тренироваться на десятках и сотнях различных задач, вы физически не сможете «подстроиться» под каждую из них и начнёте получать реальные результаты.
        \n\t• Сверьте реальные результаты с ранее сформированной оценкой.
        \n\t• Учтите ошибки при формировании новых оценок. На этом этапе очень полезно не просто отметить отклонение, а подумать, что привело к его появлению.
        \n\t• Повторяйте этот алгоритм как можно чаще для самых различных областей жизни. Сейчас цена ваших ошибок крайне мала, а наработанный опыт от этого становится ничуть не менее ценным
    </string>
    <string name="temaSevenZagolovok5">
        Полезные идеи по формированию оценки трудозатрат
    </string>
    <string name="tema7text6">
        \t• Добавляйте небольшой «буфер» (по времени, бюджету или иным критическим ресурсам) на непредвиденные обстоятельства. Чем более дальний прогноз вы строите, тем большим может быть этот «буфер» — от 5–10 % до 30–40 %. Но ни в коем случае не стоит осознанно завышать оценку в разы.
        \t• Выясните свой «коэффициент искажения»: большинство людей в силу особенности своего мышления склонны постоянно или занижать, или завышать оценку. Многократно формируя оценку трудозатрат и сравнивая её впоследствии с реальностью, вы можете заметить определённую закономерность, которую вполне можно выразить числом. Например, может оказаться, что вы склонны занижать оценку в 1.3 раза. Попробуйте в следующий раз внести соответствующую поправку.
        \t• Принимайте во внимание не зависящие от вас обстоятельства. Например, вы точно уверены, что выполните тестирование очередного билда за N человеко-часов, вы учли все отвлекающие факторы и т.д. и решили, что точно закончите к такой-то дате. А потом в реальности выпуск билда задерживается на два дня, и ваш прогноз по моменту завершения работы оказывается нереалистичным.
        \t• Задумывайтесь заранее о необходимых ресурсах. Так, например, необходимую инфраструктуру можно (и нужно!) подготовить (или заказать) заранее, т.к. на подобные вспомогательные задачи может быть потрачено много времени, к тому же основная работа часто не может быть начата, пока не будут завершены все приготовления.
        \t• Ищите способы организовать параллельное выполнение задач. Даже если вы работаете один, всё равно какие-то задачи можно и нужно выполнять параллельно (например, уточнение тест-плана, пока происходит разворачивание виртуальных машин). В случае если работа выполняется несколькими людьми, распараллеливание работы можно считать жизненной необходимостью.
        \t• Периодически сверяйтесь с планом, вносите корректировки в оценку и уведомляйте заинтересованных лиц о внесённых изменениях заблаговременно. Например, вы поняли (как в упомянутом выше примере с задержкой билда), что завершите работу как минимум на два дня позже. Если вы оповестите проектную команду немедленно, у ваших коллег появляется шанс скорректировать свои собственные планы. Если же вы в «час икс» преподнесёте сюрприз о сдвигах срока на два дня, вы создадите коллегам объективную проблему.
        \t• Используйте инструментальные средства — от электронных календарей до возможностей вашей системы управления проектом: это позволит вам как минимум не держать в памяти кучу мелочей, а как максимум — повысит точность формируемой оценки.
    </string>
    <string name="selecttem">Выберите раздел:
    </string>
    <string name="tems">Теоретический материал</string>
    <string name="tests">Тесты</string>
    <string name="test1quention1">\t1. Модель разработки ПО - это</string>
    <string name="temaTestmain1">Выберите тему теста:</string>
    <string name="buttontest1">
        Тест 1
        \nПроцессы тестирования
    </string>
    <string name="buttontest2">
        Тест 2
        \nТестирование документации
    </string>
    <string name="buttontest3">
        Тест 3
        \nВиды тестирования
    </string>
    <string name="buttontest4">
        Тест 4
        \nЧек-листы
    </string>
    <string name="buttontest5">
        Тест 5
        \nТест-кейсы
    </string>
    <string name="buttontest6">
        Тест 6
        \nОтчёты о дефектах
    </string>
    <string name="buttontest7">
        Тест 7
        \nПланирование и отчётность
    </string>
    <string name="TestExitToMenu">Вернуться в меню</string>
    <string name="temsExitToMenu">Вернуться в меню</string>
    <string name="transition1">Перейти к тесту</string>
    <string name="redtext"> \t\tК недостаткам водопадной модели
        \n\tпринято относить тот факт, что \n\tучастие пользователей ПО в ней \n\tлибо не предусмотрено вообще, либо \n\tпредусмотрено лишь косвенно
        на \n\tстадии сбора требований. \n\tС точки зрения же тестирования эта \n\tмодель плоха тем, что тестирование в \n\tявном виде
            появляется здесь лишь с \n\tсередины развития проекта, достигая \n\tсвоего максимума в самом конце.</string>
    <string name="afterred">
        \tТем не менее водопадная модель часто интуитивно применяется
        при выполнении относительно простых задач, а её недостатки послужили прекрасным отправным пунктом для создания новых моделей.
        Также эта модель в несколько усовершенствованном виде используется на крупных проектах, в которых
        требования очень стабильны и могут быть хорошо сформулированы в начале проекта (аэрокосмическая область, медицинское ПО и т.д.). Водопадная модель представлена на рисунке ниже.
    </string>
    <string name="trebram">
        \t\tТребование — описание того, \n\tкакие функции и с соблюдением \n\tкаких условий должно выполнять \n\tприложение в процессе решения \n\tполезной для пользователя \n\tзадачи.
    </string>
    <string name="aftertrebram">
        \tТребования являются отправной точкой для определения того, что проектная команда будет проектировать, реализовывать и тестировать. Элементарная логика говорит нам, что если в требованиях что-то «не то», то и реализовано будет «не то», т.е. колоссальная работа множества людей будет выполнена впустую. Эту мысль иллюстрирует рисунок.
    </string>
    <string name="bluecolor1">\t• Позволяют понять, что и с соблюдением каких условий система должна делать. \n\t• Предоставляют возможность оценить масштаб изменений и управлять изменениями. \n\t• Являются основой для формирования плана проекта (в том числе плана тестирования). \n\t• Помогают предотвращать или разрешать конфликтные ситуации. \n\t• Упрощают расстановку приоритетов в наборе задач. \n\t• Позволяют объективно оценить степень прогресса в разработке проекта.</string>
    <string name="browncolor2">
         \t• Пользовательскую и сопроводительную документацию, такую как встроенная помощь, руководство по установке и использованию, лицензионные соглашения и т.д.
 \n\t• Маркетинговую документацию, которую представители разработчика или заказчика используют как на начальных этапах (для уточнения сути и концепции проекта), так и на финальных этапах развития проекта (для продвижения продукта на рынке).
    </string>
    <string name="textbutton">Подтвердить</string>
    <string name="test1quention2">\t4. Какую модель можно протестировать в любой момент времени</string>
    <string name="test2variant1">Водопадная</string>
    <string name="test2variant2">Гибкая</string>
    <string name="test2variant3">Спиральная</string>
    <string name="test2variant4">V-образная</string>
    <string name="test1quention3" >\t5. Какая модель является логическим развитием водопадной</string>
    <string name="test3variant1" >Гибкая</string>
    <string name="test3variant2" >Спиральная</string>
    <string name="test3variant3" >Итерационная инкрементальная</string>
    <string name="test3variant4" >V-образная</string>
    <string name="test1quention4">\t2. Какой модели свойственна определённая двойственность</string>
    <string name="test4variant1">V-образная</string>
    <string name="test4variant2">Спиральная</string>
    <string name="test4variant3">Итерационная инкрементальная</string>
    <string name="test4variant4">Водопадная</string>
    <string name="test1quention5">\t3. Какое количество повторений одних и тех же стадий имеет итерационная инкрементальная модель </string>
    <string name="test5variant1">Однократное</string>
    <string name="test5variant2">Двухкратное</string>
    <string name="test5variant3">Многократное</string>
    <string name="test5variant4">Не имеет повторений</string>
    <string name="exitToMenu8">Вернуться в меню</string>
    <string name="test2quention1">\t1. Какую документацию включает в себя проектная документация?</string>
    <string name="test21variant1">Пользовательсую</string>
<string name="test21variant2">Сопроводительную</string>
<string name="test21variant3">Маркетинговую</string>
<string name="test21variant4">Все перечисленные</string>
</resources>
